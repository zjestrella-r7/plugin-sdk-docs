<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [Writing your Python Plugin](#writing-your-plugin)
  - [Version](#version)
  - [Plugin Generation](#plugin-generation)
  - [Required Variables](#required-variables)
  - [Parameters](#parameters)
  - [Logging](#logging)
  - [Errors](#errors-and-exceptions)
  - [Cache](#cache)
  - [Plugin Status](#plugin-status)
  - [Tests](#test)
  - [Functions](#functions)
  - [Methods](#methods)
  - [Helper Library](#helper-library)
  - [Triggers](#triggers)
  - [Verifying](#verifying)

## Writing your Plugin

The following sections document things you need to know to develop quality plugins.

### Version

We have Python 2.7 and 3.4 SDK images.

In your plugins Dockerfile, you can change the tag to match the version of python.
Use `python-plugin:0.2` for Python 2.7; `python-plugin:0.3` for 3.4.
```
$ head -n 1 Dockerfile
FROM komand/python-plugin:0.2
```

### Plugin Generation

As decribed in the [SDK Spec](SPEC.md) document, plugin skeletons are generated by `komand plugin generate python
plugin.spec.yaml`. Regenerating the skeleton by running the command **will overwrite the existing configuration** so be
sure to save your work. This usually means copying the code you added e.g. in the `run` method to a different location. 

If you decide to modify your plugin's scheme, by editing `plugin.spec.yaml`, you'll need to [regenerate the
plugin](REGENERATE.md) skeleton or you can manually add the JSON schema to the appropriate files. For example, say you decide to add a new
input variable called `option` to the finger action in the finger plugin. You need to edit `Input` class in the finger 
action file `finger/actions/finger.py`.

```
--- a/finger/actions/finger.py
+++ b/finger/actions/finger.py
@@ -19,6 +19,11 @@ class FingerInput(komand.Input):
       "type": "string",
       "title": "User",
       "description": "User to finger"
+    },
+    "options": {
+      "type": "string",
+      "title": "Options",
+      "description": "Options to the finger program"
     }
   },
   "required": [
--- a/finger/plugin.spec.yaml
+++ b/finger/plugin.spec.yaml
actions:
  finger:
    name: "User lookup"
    description: "Ask finger about a username"
    input:
...
         type: "string"
         description: "Finger server host"
         required: true
+      options:
+        type: "string"
+        description: "Options to the finger program"
+        required: false
     output:
       found:
         title: Found Status
```

Once edited, you can build the new plugin with `make`. The metadata section is the only section in the `plugin.spec.yaml` where
changes don't need to be made outside of the `plugin.spec.yaml` file, they'll take effect after running `make`.

### Required Variables

Output variables which are defined as `required: false`, the default, don't have to be returned as JSON from the plugin.
They can be omitted and in some cases it's better to omit them. For example, the finger plugin tries to grab many
attributes of a user from the finger daemon such as the real name, shell, home directory, etc.. There's no guarantee that
all the attributes will have values, and in some cases, the absence of values doesn't mean our plugin failed. When this
is true, we can omit returning the key/value pairs instead of setting them to empty. This is a better practice because
another plugin that depends on the output variable as input in the workflow will not get an empty value and try to
proceed with it but rather the workflow stops there.

Example of returning all variables, irrespective of them having a meaningful value:
```
variables = {
  'Host': ip,
  'Name': 'N/A', # Not available is used to illustrate non-meaningful
}

return variables
```

A contrived example of returning only meaningful variables:
```
variables = {
  'Host': ip,
  'Name': ''
}
if variables.get('Host') == None:
  del variables['Host']
if variables['Host'] == '':
  del variables['Host']
if variables.get('Name') == None:
  del variables['Name']
if variables['Name'] == '':
  del variables['Name']
return variables
```

In other words, don't do this where we manually fill out values (e.g. `'N/A'`):
![All Variables](imgs/var_all.png)

We have a helper function called `clean_dict` that will automatically remove keys with `None` type values and empty
strings. It can be called like `clean_dictionary = komand.helper.clean_dict(unclean_dictionary)`, more information in
the [Helper Library](#helper-library)

### Parameters

#### Actions

Input variables defined in the `plugin.spec.yaml` file are available in a dictionary called `params` where the value can be accessed
by the variable/key name, these are our input variables names described in the `plugin.spec.yaml` file. We can do this the long way or in shorter form:
```
def run(self, params):
  ...
  self.input.parameters['var']
  params['var']
```

We can also use the better `params.get()` method which

* Allows optional default value if the key is missing
* Returns `None` if the key is missing whereas `params['var'] would raise `KeyError`.

```
value = params.get('var', 'blah')
```

#### Triggers

Testing triggers using Docker requires the use of the `--debug` option otherwise the trigger will fail due to attempts
to post events to an http URL that's not available.

#### Connections

You can access the connection variables defined in `plugin.spec.yaml` while in `connection.py` using a dictionary called `params` where 
the value can be accessed by the key. We can do this the long way or in shorter form:

```
def connect(self, params):
     ...
     value = params.get('var')
     value = self.parameters['var']
```

You also need to access the connection variables in the `run` method to get the connection info. It's similar to the other examples.

```
def run(self, params):
  ...
  value = self.connection.var
```

### Logging

Log informational messages including warnings and errors, they're displayed to the user in the Log section of the Job Output.

![Log Output](imgs/log_var.png)

Informational logging can be done by raising an exception or logging directly, a few examples are below.
```
# Python
logging.info("connecting")
raise ValueError('connecting')
raise Exception('connecting')
```

Note that the raising of exceptions will cause the plugin to fail.

### Errors and Exceptions

Raising exceptions is how we cause plugins to abort. We want them to abort when something goes wrong so the workflow
doesn't continue.

We can manually raise exceptions:
```
# Python
raise ValueError('connecting')
raise Exception('connecting')
```

For error handling, we should handle exceptions from the methods and functions in python libraries.
We then log a detailed message, and raise an exception to abort.

Example for handling errors from a URL request:
```
try:
  resp = urllib2.urlopen(url)
  # Return from function if successful
  return resp
except urllib2.HTTPError, e:
  logging.error('HTTPError: %s for %s', str(e.code), url)
except urllib2.URLError, e:
  logging.error('URLError: %s for %s', str(e.reason), url)
# After catching and logging errors, manually raise an exception to abort
raise Exception('URL Request Failed')
```

### Cache

Plugins can use persistent storage for caching files using the `enable_cache: true` in the metadata section of plugin spec file.
`/var/cache` can then be used for storage across all the plugin's containers but not in containers of other plugins. For plugins that download down files from the internet, it makes it easy to check if the file already exists in the cache.

Example
```
import os
...
cache_dir  = '/var/cache'
cache_file = cache_dir + '/' + 'mycache'

if os.path.isdir(cache_dir):
  if os.path.isfile(cache_file):
    f = open(cache_file, 'rw')
    contents = f.read()
    # Do comparison
  else:
    # Create cachefile for next time
```

We have helper functions for dealing with the cache, see [Helper Library](#helper-library)
```
file = open_cachefile('/var/cache/mycache')
remove_cachefile('/var/cache/mycache')
True
check_cachefile('/var/cache/mycache')
False
```

### Plugin Status
Plugin failures are caused by raising exceptions. Do this when something doesn't go right and the next best option is to fail.
```
# Python
raise ValueError('connecting')
raise Exception('connecting')
```

### Tests

The test method is used to provide tests of the plugin by returning JSON. It should be completed with practical test(s) of plugin functionality.
Raising an exception will cause the test method to fail.

```
# Python
def test(self, params={}):
  """TODO: Test action"""
  return {}
```

Tests are executed in the Komand WUI after configuring a plugin. A log of the JSON output is also viewable.

![Testing Interface](imgs/test.png)

![Testing Log](imgs/test_log.png)

The user parameters are available in the method as well.

If the plugin is simple enough:
* It doesn't present a rate limiting issue
* Itexcutes quickly

You can have the test method call the run method.
```
def test(self, params={}):
  return self.run(params={})
```

Testing Examples:
* Successful connections to API or service
* Validating known output of command

Example for testing the `hashit` plugin that generates hashes of a string. We can test that hashing works by comparing
known hashes of a string against the code the hashit plugin uses to generate them. An exeception is raised if the hashes
do not match, otherwise upon success we return the JSON object of hashes.
```
def test(self, params={}):
        a = 'test'
        # Hashes of 'test'
        real_hashes = {
          'md5': '098f6bcd4621d373cade4e832627b4f6',
          'sha1': 'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3',
          'sha256': '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08',
          'sha512': 'ee26b0dd4af7e749aa1a8ee3c10ae9923f618980772e473f8819a5d4940e0db27ac185f8a0e1d5f84f88bc887fd67b143732c304cc5fa9ad8e6f57f>
        }

        test_hashes={}
        test_hashes['md5']    = hashlib.md5(a).hexdigest()
        test_hashes['sha1']   = hashlib.sha1(a).hexdigest()
        test_hashes['sha256'] = hashlib.sha256(a).hexdigest()
        test_hashes['sha512'] = hashlib.sha512(a).hexdigest()

        # Test against correct hashes of string 'test'
        for alg in real_hashes:
          if test_hashes[alg] != real_hashes[alg]:
            raise Exception('Hash failed')

        return test_hashes
```

### Functions

Use good programming practices such as breaking the program into smaller functions. This makes the plugins more readable and manageable.
We recommend creating a utils.py file in the actions|triggers directory with your functions and importing it in the respective actions|triggers files.

```
$ ls actions/
__init__.py*      filter_bytes.py*  filter_string.py* utils.py*
$ head actions/filter_string.py
import komand
import logging
import json
import utils
```

The functions are put in the `utils.py` file
```
$ head actions/utils.py
import re

def csv_syntax_good(csv):
    parsed = parse_csv_string(csv)
    size = len(parsed[0])
    for row in parsed:
        if len(row) != size:
            return False
    return True

def csv_syntax_bad(csv):
...
```

### Methods

Use good programming practices such as breaking the program into smaller functions or methods. This makes the plugins more readable and manageable.

An example below is provided that we can use instead of doing a bunch of `re.search`es and conditionals to test the existence of a value.
The regex in the `get_value` method extracts the value from the `\nkey: value` pair match in the stdout string.

```
...
def get_value(self, key, stdout):
    '''Extracts value from key: value pair'''
    # Example: regex = "\nDomain Name: (google.com)\n"
    regex = r"\n" + re.escape(key) + r": (.*)\n"
    r = re.search(regex, stdout)
    # Only return the value in the group 1 if it exists
    if hasattr(r, 'group'):
      if r.lastindex == 1:
        return r.group(1)
...

def run(self, params={}):
# Initialize list with keys for matching
  keys = [
    'Domain Name',
    'Registrar WHOIS Server',
    'Updated Date',
    'Creation Date',
    'Registrar',
    'Registrar Abuse Contact Email',
    'Registrar Abuse Contact Phone',
    'Registrant Country',
  ]

  for key in keys:
    # Iterate over keys and store the extracted values into results
    results[key] = self.get_value(key, stdout)

  return results
```

Once you define the function you can call it in the same python file by referring to itself e.g. `self.get_value(...)`


### Helper Library

We have a helper library that aids in common tasks. Functions can be accessed by `komand.helper.funcname` where funcname
is the name of the function.

You can execute code in `test` method or similar to get a list of the available functions. This will error out but you
will see them. Use `help(komand.helper.funcname)` to get specifics. Though, we hope the documentation is sufficient
enough and you don't have to do this hackish thing.
```
# Add to test function in <action>.py
dir(komand.helper)
# Get more info on a specific function
help(komand.helper.extract_value)

# Run these in your plugins directory e.g. plugins/myplugin
make
docker run -i komand/myplugin sample <action>  > test.json
docker run -i komand/myplugin test < test.json
```

List of current functions:
* clean_dict - Returns a new dict absent of keys with `None` type or empty strings
* clean_list - Returns a new list absent of elements with `None` type or empty strings
* open_file - Returns a file object read only or None
* extract_value - A regular expression helper
* check_cachefile - Checks if a cachefile exists and returns a boolean value
* open_cachefile - Returns a file object from cache, and creates a new one if it doesn't exist
* remove_cachefile - Removes a file from the cache and returns a boolean value for status
* lock_cache - Checks if a lock file exists. If so, it waits, else it creates one and returns boolean value
* unlock_cache - Removes a lock file after waiting a specified amount of time and returns a boolean value
* get_hashes_string - Returns a dictionary of hashes from a string
* check_hashes - Returns a boolean on whether checksum was a hash of provided string. Supports MD5, SHA(1,256,512)
* open_url - Returns a URL object from a url and optional timeout, SSL verification, and HTTP client headers
* get_url_filename - Returns a filename from url using content-disposition or file name in url, or `None` type
* exec_command - Returns a dictionary of stdout, stderr, and return code of executed command

#### Examples:

* `clean_dict(dict)` takes a dictionary as an argument and returns a new, cleand, list
```
>>> a = { 'a': 'stuff', 'b': 1, 'c': None, 'd': 'more', 'e': '' }
# Keys c and e are removed
>>> komand.helper.clean_dict(a)
{'a': 'stuff', 'b': 1, 'd': 'more'}
```

* `clean_list(lst)` takes a list as an argument and returns a new, cleaned, list
```
>>> lst = [ 'stuff', 1, None, 'more', '', None, '' ]
>>> clean_list(lst)
['stuff', 1, 'more']
```

* `open_file('path')` takes a file path as a string to open and returns a file object on success or None
```
>>> f = open_file('/tmp/testfile')
>>> f.read()
'test\n'
```

* `check_cachefile('path')` takes a string of the file path to check
```
>>> komand.helper.check_cachefile('/var/cache/mycache')
True
# This works too, /var/cache is not required
>>> komand.helper.check_cachefile('mycache')
True
>>> komand.helper.check_cachefile('nofile')
False
```

* `remove_cachefile('path')` takes a file path as a string
```
>>> os.listdir('/var/cache')
['test']
>>> komand.helper.remove_cachefile('test')
True
>>> os.listdir('/var/cache')
[]
```

* `open_cachefile('file')` takes a file path as a string
```
>>> f = komand.helper.open_cachefile('/var/cache/test')
>>> f.read()
'stuff\n'
>>> os.listdir('/var/cache')
[]
>>> f = komand.helper.open_cachefile('/var/cache/myplugin/cache.file')
# The file has been created
>>> komand.helper.check_cachefile('/var/cache/myplugin/cache.file')
True
```

* `lock_cache('file')` takes a file path as a string
```
>>> f = komand.helper.lock_cache('/var/cache/lock/lock1')
>>> f
True
```

* `unlock_cache('file', delay)` Takes a file path as a string and a delay length in seconds as an int or a float. 
```
>>> delay = 60
>>> f = komand.helper.unlock_cache('/var/cache/lock/lock1', delay)
# Sixty seconds later
>>> f
True
>>> file_name = '/var/cache/lock/lock1'
>>> f = komand.helper.unlock_cache(file_name, 60)
# Sixty seconds later
>>> f
True
```

* `get_hashes_string(str)` returns a dictionary of hashes from a string
* `check_hashes(src, checksum)` returns a boolean on whether checksum was a hash of provided string
```
>>> get_hashes_string('thisisastring')
{u'sha256': '572642d5581b8b466da59e87bf267ceb7b2afd880b59ed7573edff4d980eb1d5', u'sha1':
'93697ac6942965a0814ed2e4ded7251429e5c7a7', u'sha512':
'9145416eb9cc0c9ff3aecbe9a400f21ca2b99c927f63a9a245d22ac4fe6fe27036643e373708e3bdf7ace4f3b52573182ec6d1f38c7d25f9e06144617ad1cdc8',
u'md5': '0bba161a7165a211c7435c950ee78438'}
>>> check_hashes('thisisastring', '0bba161a7165a211c7435c950ee78438')
True
>>> f = open_file('/bin/ls')
>>> check_hashes(f.read(), 'c7485092a3159745044ef9ebed9d4bcdca057bab')
```

* `extract_value()` Takes 4 arguments that regexes/patterns as strings
```
>>> string = '\n\tShell: /bin/bash\n\t'
>>> komand.helper.extract_value(r'\s', 'Shell', r':\s(.*)\s', string)
'/bin/bash'
```

* `open_url('http://blah.com')` takes a URL as a string and optional timeout as int, verify as boolean, and headers.
A urllib2 obj is returned upon success. `None` is returned if a 304 Not modified is the response.
```
>>> urlobj = open_url('http://google.com')
>>> urlobj.read()
'<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" lang="en"><head><meta content="Se...'
>>> urlobj = open_url(url, Range='bytes=0-3', Authorization='aslfasdfasdfasdfasdf')
>>> urlobj.read()
Auth
>>> urlobj = open_url(url, timeout=1, User_Agent='curl/0.7.9', If_None_Match=etag)
ERROR:root:HTTPError: 304 for http://24.151.224.211/ui/1.0.1.1038/dynamic/login.html
>>> type(a)
<type 'NoneType'>
>>> urlobj = open_url(url, User_Agent='curl/0.7.9', If_Modified_Since=mod)
ERROR:root:HTTPError: 304 for http://24.151.224.211/ui/1.0.1.1038/dynamic/login.html
```

* `get_url_filename('http://blah.com')` takes a URL as a string, returns filename as string or None
```
>>> url = 'http://www.irongeek.com/robots.txt'
>>> get_url_filename(url)
'robots.txt'
>>> get_url_filename('http://203.66.168.223:83/')
'Create_By_AutoWeb.htm'
>>> if get_url_filename('http://www.google.com') is None:
...   print 'No file found'
No file found
```

* `exec_command('path arg1 arg2')` takes a command and its arguments as a string
```
>>> exec_command('/bin/ls')
{'rcode': 0, 'stderr': '', 'stdout':
'GO.md\nPYTHON.md\nREADME.md\nSPEC.md\nball.pyc\nimgs\nold.py\nplugins.py\nplugins.pyc\nstatic.py\nstatic.pyc\n'}
```

### Triggers

Triggers, long running processes in Docker containers, continously emit events from a loop. All workflows must start by emiting an event, 
and this is why the first step in the Workflow Builder is to select a plugin that supports Triggers.

`self.send` is a method that emits the actual event, it takes a dictionary as its argument. Instead of returning a dictionary that matches the
schema as we do it actions, for triggers we pass the dictionary matching the schema to `self.send(dict)` in a loop.

If triggers were configured in the spec file, trigger code is available in the trigger files at `<plugin_name>/komand_<plugin_name>/triggers/<trigger_name>.py` 
```
def run(self, params={}):
    """Run the trigger"""
    while True:
       # TODO: Implement this
       self.send({})
       time.sleep(5)
```

The code is intended to be put in the `while` loop but above the `self.send` method, right where the TODO comment lies.

You can adjust the timer to suit the plugins needs. By default, it emits an event every 5 seconds.

### Verifying

Before committing the plugin, always verify that the functionality works to the top of the stack. Plugins should be user
friendly and the best way to test and figure out if your plugin meets those requirements is to get it working in Komand
product. All developers should do this.

You can import the plugin via the command-line with `komand plugin register <plugin.tgz>` or using the web interface
described below.

![Import Plugin](imgs/import_plugin.png)

1. Open up the web interface `https://127.0.0.1:8888` for the Vagrant config
2. Authenticate
3. `Settings -> Import A Plugin`
4. Choose the tarball that the `makefile` generated
5. Create a Workflow to use it, it's easiest to use the API Trigger to kick it off.
![Workflow](imgs/api_trigger.png)
![Workflow](imgs/curl.png)
6. Publish the workflow
7. Start the workflow by executing the CURL command with the necessary inputs
```
curl -X POST -d '{"blah": "things", "blah2": "morethings"}' http://komand.dev.komand.local:8000/v2/workflows/46/events?api_key=b943197b-7d3f-4c77-b704-c2e4c55c6c
```
8. Check the closed jobs for the results

Make sure everything makes sense especially the text used to described the plugin, its input, and outputs.
